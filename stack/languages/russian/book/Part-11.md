## Часть 11

[![](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11.svg)](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11.svg)

<em>11.0 Часть 11 (кликабельно)</em>

### Обновление компонента

Комментарий в коде, описывающий метод, говорит следующее:
>‘Выполняет обновление примонтированного компонента. Вызываются методы componentWillReceiveProps и shouldComponentUpdate, затем (при условии, что последний не предотвратил обновление) вызываются остальные методы жизненного цикла, и затем DOM-представление компонента обновляется. По умолчанию, используются React'овские реализации рендеринга и алгоритма реконсиляции. Сложным клиентам может потребоваться переопределить этот метод.’

Хорошо, звучит логично.

Первое что мы тут сделаем, это проверим, что `props` (1) изменились - технически, метод `updateComponent` может быть вызван в двух сценариях, когда вызывался `setState` и когда менялись `props`. Если `props` на самом деле поменялись, то будет вызван метод `componentWillReceiveProps`. Затем React пересчитает `nextState` (2) опираясь на очередь висящих изменений `pending state queue` (очередь объектов с частичными состояниями которые мы выставляли ранее, в нашем случае очередь будет выглядеть как [{message: "сообщение в состоянии по щелчку"}]). Конечно, в случае когда мы попадаем в метод только из-за обновления `props`, состояние мы трогать не будем.

Следующим шагом мы выставим `shouldUpdate` в значение по умолчанию `true` (3). Этим собственно и объясняется, что если `shouldComponentUpdate` в компоненте не определялся, то такой компонент по умолчанию будет обновлен. Затем мы проверим, является ли наше обновление принудительным, т.е. было ли оно вызвано через `force update` - как вы знаете, у компонента можно вызвать метод `forceUpdate` чтобы обновить его без изменения `state` или `props`, но согласно официальной документации React'а использовать его не рекомендуется. В случае принудительного обновления, компонент будет обновлен сразу же, иначе сначала будет вызван метод `shouldComponentUpdate`, и `shouldUpdate` будет переопределен результатом этого метода. Если мы поймем, что компонент обновлять не следует, React'у все равно надо будет выставить `props` и `state`, но остальную часть обновления можно будет пропустить. 

### Хорошо, *Часть 11* мы закончили.

Давайте вспомним, как мы сюда попали - глянем еще раз на схему, затем уберем из нее избыточные и менее важные куски, и она станет вот такой:

[![](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11-A.svg)](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11-A.svg)

<em>11.1 Часть 11 упрощенно (кликабельно)</em>

Уберем пустое место и поправим выравнивание:

[![](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11-B.svg)](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11-B.svg)

<em>11.2 Часть 11 упрощенно и с рефакторингом (кликабельно)</em>

Вот теперь отлично. По сути, это все что происходит на этой стадии. Поэтому мы возьмем эту ключевую выдержку из *Части 11* и поместим ее на итоговую схему процесса `обновления`:

[![](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11-C.svg)](https://rawgit.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/master/stack/images/11/part-11-C.svg)

<em>11.3 Часть 11 ключевые моменты (кликабельно)</em>

И мы закончили!


[На следующую страницу: Часть 12 >>](../../../../stack/book/Part-12.md)

[<< На предыдущую страницу: Часть 10](./Part-10.md)


[К оглавлению](./README.md)
